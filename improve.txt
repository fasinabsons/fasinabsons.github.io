I got some ideas to Optimize the code and also remove duplicate lines so that we get perfect scanning
// I want you to improve the ocr scanner
// Enhanced interfaces for better data handling
interface ExtractedData {
  emails: string[];
  phones: string[];
  websites: string[];
  cleanLines: string[];
  rawText: string;
  confidence: number;
  structuredData: StructuredTextData;
}

interface StructuredTextData {
  lines: TextLine[];
  blocks: TextBlock[];
  words: TextWord[];
}

interface TextLine {
  text: string;
  confidence: number;
  bbox: BoundingBox;
  type: 'name' | 'title' | 'company' | 'contact' | 'address' | 'unknown';
}

interface TextBlock {
  lines: TextLine[];
  type: 'header' | 'body' | 'footer';
  confidence: number;
}

interface TextWord {
  text: string;
  confidence: number;
  bbox: BoundingBox;
}

interface BoundingBox {
  x0: number;
  y0: number;
  x1: number;
  y1: number;
}

interface ColorInfo {
  hex: string;
  rgb: string;
  frequency: number;
  prominence: number; // Added for better color ranking
}

interface EnhancedContact extends Contact {
  confidence?: number;
  logoColors?: ColorInfo[];
  extractedPhones?: string[];
  extractedEmails?: string[];
  processingMetrics?: ProcessingMetrics;
}

interface ProcessingMetrics {
  ocrTime: number;
  preprocessingTime: number;
  parsingTime: number;
  totalTime: number;
  imageQuality: number;
}

// Optimized field detection patterns with improved accuracy
const FIELD_PATTERNS = {
  email: [
    // Most accurate email pattern first
    /\b[a-zA-Z0-9](?:[a-zA-Z0-9._-]*[a-zA-Z0-9])?@[a-zA-Z0-9](?:[a-zA-Z0-9.-]*[a-zA-Z0-9])?\.[a-zA-Z]{2,}\b/gi,
    // Pattern for emails with prefixes (E: email@domain.com)
    /(?:E[:\s]+|Email[:\s]+|Mail[:\s]+)([a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,})/gi,
    // Fallback pattern for malformed emails
    /[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,}/gi
  ],
  phone: [
    // UAE mobile formats (most common first)
    /(?:\+971|971)[-.\s]?(?:50|55|56|58)[-.\s]?\d{3}[-.\s]?\d{4}/g,
    // UAE landline formats
    /(?:\+971|971)[-.\s]?[2-4679][-.\s]?\d{3}[-.\s]?\d{4}/g,
    // Phone with prefixes (T:, Tel:, Phone:)
    /(?:T[:\s]+|Tel[:\s]+|Phone[:\s]+|P[:\s]+)(\+?971[-.\s]?\d{1,2}[-.\s]?\d{3,4}[-.\s]?\d{4})/gi,
    // Fax with prefixes
    /(?:F[:\s]+|Fax[:\s]+)(\+?971[-.\s]?\d{1,2}[-.\s]?\d{3,4}[-.\s]?\d{4})/gi,
    // International formats
    /\+\d{1,3}[-.\s]?\d{1,4}[-.\s]?\d{3,4}[-.\s]?\d{3,4}/g,
    // General formats
    /\b\d{3}[-.\s]?\d{3}[-.\s]?\d{4}\b/g
  ],
  website: [
    // Full URLs first
    /https?:\/\/(?:www\.)?[-a-zA-Z0-9@:%._+~#=]{1,256}\.[a-zA-Z0-9()]{1,6}\b(?:[-a-zA-Z0-9()@:%_+.~#?&=]*)/gi,
    // Domain names with common extensions
    /\b(?:www\.)?[a-zA-Z0-9](?:[a-zA-Z0-9-]*[a-zA-Z0-9])?\.(com|org|net|edu|gov|ae|co\.ae|io|tech|biz|info|co\.uk|co|me)\b/gi,
    // Email domains as potential websites
    /@([a-zA-Z0-9.-]+\.[a-zA-Z]{2,})/gi
  ],
  name: [
    // Full names with proper capitalization
    /^[A-Z][a-z]+(?:\s+[A-Z][a-z]*\.?)*\s+[A-Z][a-z]+$/m,
    // Names with middle initials
    /^[A-Z][a-z]+\s+[A-Z]\.\s+[A-Z][a-z]+$/m,
    // Single word names (first or last only)
    /^[A-Z][a-z]{2,}$/m
  ],
  title: [
    // Executive titles
    /\b(?:Chief|Senior|Executive|Vice\s+President|President|Director|Manager|Head\s+of)\b[^.]*?(?:Officer|Manager|Director|Engineer|Analyst|Consultant)/gi,
    // Engineering titles
    /\b(?:Senior|Lead|Principal|Chief)?\s*(?:Software|Hardware|Mechanical|Electrical|Civil|Chemical|Systems|Network|DevOps|Full[- ]?Stack)?\s*(?:Engineer|Developer|Architect|Analyst|Specialist)/gi,
    // Business titles
    /\b(?:Business\s+Development|Sales|Marketing|Operations|Project|Product|Program)\s+(?:Manager|Director|Coordinator|Specialist|Lead)/gi,
    // Professional titles
    /\b(?:Consultant|Analyst|Specialist|Coordinator|Administrator|Executive|Associate|Assistant|Representative)/gi
  ],
  company: [
    // Company with legal suffixes
    /\b[A-Z][A-Za-z\s&]+(?:LLC|Inc\.?|Corp\.?|Ltd\.?|Limited|Company|Co\.?|Group|Solutions|Services|Technologies|Systems|International|Global|Holdings|Partners|Associates|Enterprises|Industries|Trading|Consulting)\b/gi,
    // Technical company names
    /\b[A-Z][A-Za-z\s]*(?:Electromechanical|Engineering|Contracting|Construction|Manufacturing|Technology|Software|Hardware|Systems|Solutions|Services)\b/gi,
    // Well-known company patterns
    /\b(?:ARCO|Sicuro|ADNOC|Emirates|Etisalat|Du|Mashreq|FAB|ENOC|DEWA|SEWA|FEWA)\b[A-Za-z\s]*/gi
  ],
  address: [
    // P.O. Box addresses
    /(?:P\.?O\.?\s*Box|PO\s*Box)[:\s]*\d+(?:[,\s]*[A-Za-z\s]+)*(?:[,\s]*(?:UAE|United\s+Arab\s+Emirates))?/gi,
    // Street addresses
    /\b\d+[A-Za-z]?\s+[A-Z][A-Za-z\s,]+(Street|St|Avenue|Ave|Road|Rd|Drive|Dr|Boulevard|Blvd|Lane|Ln)/gi,
    // Cities and countries
    /\b(?:Abu\s+Dhabi|Dubai|Sharjah|Ajman|Ras\s+Al\s+Khaimah|Fujairah|Umm\s+Al\s+Quwain|Al\s+Ain|Riyadh|Jeddah|Mecca|Medina|Muscat|Mumbai|Delhi|Karachi|Lahore|Doha|Dhaka|Manila|London|Toronto|Sydney|Tokyo|Seoul|Beijing|New\s+York|Stockholm|Tehran|Khartoum)\b/gi,
    // Countries
    /\b(?:UAE|United\s+Arab\s+Emirates|Saudi\s+Arabia|KSA|Oman|India|Pakistan|Qatar|Bangladesh|Philippines|UK|United\s+Kingdom|Canada|Australia|Japan|Korea|China|USA|United\s+States|Sweden|Iran|Sudan)\b/gi
  ]
};

// Optimized OCR text cleaning with better error detection
const cleanOCRText = (text: string, confidence: number): { cleanedText: string; qualityScore: number } => {
  const lines = text.split('\n').map(line => line.trim()).filter(line => line.length > 0);
  const cleanedLines: string[] = [];
  let qualityScore = confidence;
  
  for (const line of lines) {
    // Skip obvious OCR garbage
    if (isOCRGarbage(line)) {
      qualityScore -= 2;
      continue;
    }
    
    // Preserve contact information lines as-is
    if (isContactInfo(line)) {
      cleanedLines.push(line);
      continue;
    }
    
    // Clean and validate text lines
    const cleaned = cleanTextLine(line);
    if (cleaned && isValidTextLine(cleaned)) {
      cleanedLines.push(cleaned);
    } else {
      qualityScore -= 1;
    }
  }
  
  // Bonus for having expected business card elements
  if (hasExpectedElements(cleanedLines)) {
    qualityScore += 10;
  }
  
  return {
    cleanedText: cleanedLines.join('\n'),
    qualityScore: Math.max(0, Math.min(100, qualityScore))
  };
};

const isOCRGarbage = (line: string): boolean => {
  // Check for common OCR garbage patterns
  if (line.length <= 1) return true;
  if (/^[^a-zA-Z0-9@+.]*$/.test(line)) return true; // Only special characters
  if (/^[A-Z]{1,2}$/.test(line) && !/^(IT|AI|HR|PR|QR|US|UK|UAE)$/.test(line)) return true; // Single/double letters (except valid abbreviations)
  if (line.split('').every(char => char === char.toUpperCase()) && line.length > 10 && !/[@+\d]/.test(line)) return true; // All caps without contact info
  
  // Gibberish detection - check for unusual character patterns
  const consonantClusters = (line.match(/[bcdfghjklmnpqrstvwxyzBCDFGHJKLMNPQRSTVWXYZ]{4,}/g) || []).length;
  if (consonantClusters > 2) return true;
  
  return false;
};

const isContactInfo = (line: string): boolean => {
  return /[@+]/.test(line) || 
         /^[TFE]\s+/.test(line) || 
         /\b\d{3,}/.test(line) ||
         /www\./i.test(line) ||
         /\.com|\.org|\.net|\.ae/i.test(line);
};

const cleanTextLine = (line: string): string => {
  let cleaned = line.trim();
  
  // Fix common OCR character substitutions
  const substitutions: { [key: string]: string } = {
    '0': 'O', '1': 'I', '5': 'S', '8': 'B', '6': 'G',
    'rn': 'm', 'cl': 'd', 'li': 'h', 'vv': 'w'
  };
  
  // Apply substitutions cautiously (only for text that looks like names/companies)
  if (/^[A-Z]/.test(cleaned) && cleaned.length <= 30 && !/[@+\d]/.test(cleaned)) {
    for (const [wrong, right] of Object.entries(substitutions)) {
      // Only substitute if it creates a more readable word
      const potential = cleaned.replace(new RegExp(wrong, 'g'), right);
      if (isMoreReadable(potential, cleaned)) {
        cleaned = potential;
      }
    }
  }
  
  // Remove extra whitespace
  cleaned = cleaned.replace(/\s+/g, ' ').trim();
  
  return cleaned;
};

const isMoreReadable = (candidate: string, original: string): boolean => {
  // Simple heuristic: candidate is more readable if it has better vowel/consonant balance
  const vowels = 'aeiouAEIOU';
  const candidateVowels = (candidate.match(/[aeiouAEIOU]/g) || []).length;
  const originalVowels = (original.match(/[aeiouAEIOU]/g) || []).length;
  const candidateLength = candidate.replace(/[^a-zA-Z]/g, '').length;
  const originalLength = original.replace(/[^a-zA-Z]/g, '').length;
  
  if (candidateLength === 0 || originalLength === 0) return false;
  
  const candidateRatio = candidateVowels / candidateLength;
  const originalRatio = originalVowels / originalLength;
  
  // Better ratio is closer to natural language (0.2-0.5)
  const idealRatio = 0.35;
  return Math.abs(candidateRatio - idealRatio) < Math.abs(originalRatio - idealRatio);
};

const isValidTextLine = (line: string): boolean => {
  if (line.length < 2) return false;
  
  // Must contain at least some letters
  if (!/[a-zA-Z]/.test(line)) return false;
  
  // Reject lines with too many numbers (unless they look like addresses)
  const letterCount = (line.match(/[a-zA-Z]/g) || []).length;
  const numberCount = (line.match(/\d/g) || []).length;
  if (numberCount > letterCount && !/(?:box|street|st|avenue|ave|road|rd)/i.test(line)) return false;
  
  return true;
};

const hasExpectedElements = (lines: string[]): boolean => {
  const hasEmail = lines.some(line => /@/.test(line));
  const hasPhone = lines.some(line => /\+?\d{3,}/.test(line));
  const hasName = lines.some(line => /^[A-Z][a-z]+\s+[A-Z][a-z]+/.test(line));
  
  return (hasEmail || hasPhone) && hasName;
};

// Enhanced OCR with multi-pass processing and quality assessment
export const scanBusinessCard = async (imageFile: File): Promise<Contact> => {
  const startTime = performance.now();
  let processedImage = imageFile;
  
  try {
    // Step 1: Image quality assessment and preprocessing
    const preprocessStart = performance.now();
    const { enhancedImage, qualityMetrics } = await enhanceImageForOCR(imageFile);
    processedImage = enhancedImage;
    const preprocessTime = performance.now() - preprocessStart;
    
    // Step 2: Extract logo colors for QR styling
    const logoColors = await extractLogoColors(processedImage);
    
    // Step 3: Multi-pass OCR for better accuracy
    const ocrStart = performance.now();
    const ocrResults = await performMultiPassOCR(processedImage, qualityMetrics);
    const ocrTime = performance.now() - ocrStart;
    
    // Step 4: Advanced text parsing with confidence scoring
    const parseStart = performance.now();
    const extractedData = extractAdvancedFields(ocrResults.text, ocrResults.confidence, ocrResults.structured);
    const parseTime = performance.now() - parseStart;
    
    // Step 5: Build enhanced contact with metrics
    const contact = buildEnhancedContact(extractedData, logoColors);
    const totalTime = performance.now() - startTime;
    
    // Add processing metrics
    (contact as EnhancedContact).processingMetrics = {
      ocrTime,
      preprocessingTime: preprocessTime,
      parsingTime: parseTime,
      totalTime,
      imageQuality: qualityMetrics.overallQuality
    };
    
    console.log('=== OCR PROCESSING COMPLETE ===');
    console.log(`Total time: ${totalTime.toFixed(2)}ms`);
    console.log(`Image quality: ${qualityMetrics.overallQuality.toFixed(1)}/100`);
    console.log(`OCR confidence: ${ocrResults.confidence.toFixed(1)}%`);
    console.log(`Extracted: ${extractedData.emails.length} emails, ${extractedData.phones.length} phones`);
    console.log('================================');
    
    return contact;
    
  } catch (error) {
    console.error('Enhanced OCR processing failed:', error);
    
    // Fallback to basic OCR if advanced processing fails
    try {
      return await basicOCRFallback(processedImage);
    } catch (fallbackError) {
      console.error('Fallback OCR also failed:', fallbackError);
      throw new Error(`OCR processing failed: ${error instanceof Error ? error.message : 'Unknown error'}`);
    }
  }
};

// Multi-pass OCR with different configurations for optimal results
const performMultiPassOCR = async (imageFile: File, qualityMetrics: any): Promise<{
  text: string;
  confidence: number;
  structured: any;
}> => {
  const worker = await createWorker('eng', 1, {
    logger: m => {
      if (m.status === 'recognizing text') {
        console.log(`OCR Progress: ${Math.round(m.progress * 100)}%`);
      }
    }
  });
  
  try {
    // Configure OCR based on image quality
    const params = getOptimalOCRParams(qualityMetrics);
    await worker.setParameters(params);
    
    // Primary OCR pass
    const primaryResult = await worker.recognize(imageFile);
    
    // If confidence is low, try alternative configuration
    let bestResult = primaryResult;
    if (primaryResult.data.confidence < 70) {
      console.log('Low confidence detected, trying alternative OCR configuration...');
      
      await worker.setParameters({
        ...params,
        tessedit_pageseg_mode: PSM.SINGLE_BLOCK,
        preserve_interword_spaces: '0'
      });
      
      const alternativeResult = await worker.recognize(imageFile);
      
      // Use the result with higher confidence
      if (alternativeResult.data.confidence > bestResult.data.confidence) {
        bestResult = alternativeResult;
      }
    }
    
    const { cleanedText, qualityScore } = cleanOCRText(bestResult.data.text, bestResult.data.confidence);
    
    return {
      text: cleanedText,
      confidence: Math.min(bestResult.data.confidence, qualityScore),
      structured: bestResult.data
    };
    
  } finally {
    await worker.terminate();
  }
};

const getOptimalOCRParams = (qualityMetrics: any) => {
  const baseParams = {
    tessedit_char_whitelist: 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789@.+-()[]{}/:;,!?&%# \n\r\t',
    preserve_interword_spaces: '1',
    classify_enable_learning: '0',
    classify_enable_adaptive_matcher: '1',
    textord_noise_area_ratio: '0.7',
    language_model_penalty_non_freq_dict_word: '0.1',
    language_model_penalty_non_dict_word: '0.15'
  };
  
  // Adjust parameters based on image quality
  if (qualityMetrics.sharpness > 0.7) {
    return {
      ...baseParams,
      tessedit_pageseg_mode: PSM.AUTO_OSD,
      textord_heavy_nr: '1'
    };
  } else {
    return {
      ...baseParams,
      tessedit_pageseg_mode: PSM.SINGLE_BLOCK,
      textord_heavy_nr: '0',
      textord_noise_area_ratio: '0.5'
    };
  }
};

// Advanced image enhancement with quality assessment
const enhanceImageForOCR = async (file: File): Promise<{
  enhancedImage: File;
  qualityMetrics: any;
}> => {
  return new Promise((resolve, reject) => {
    const canvas = document.createElement('canvas');
    const ctx = canvas.getContext('2d');
    if (!ctx) {
      reject(new Error('Canvas not supported'));
      return;
    }

    const img = new Image();
    img.onload = () => {
      try {
        // Calculate optimal size with better scaling
        const maxSize = 2400; // Increased for better quality
        let { width, height } = img;
        const originalArea = width * height;
        
        if (width > maxSize || height > maxSize) {
          const ratio = Math.min(maxSize / width, maxSize / height);
          width = Math.round(width * ratio);
          height = Math.round(height * ratio);
        }

        canvas.width = width;
        canvas.height = height;
        ctx.drawImage(img, 0, 0, width, height);
        
        const imageData = ctx.getImageData(0, 0, width, height);
        const originalData = new Uint8ClampedArray(imageData.data);
        
        // Assess image quality before processing
        const qualityMetrics = assessImageQuality(imageData);
        
        // Apply adaptive enhancement based on quality
        const enhancedData = applyAdaptiveEnhancement(imageData, qualityMetrics);
        
        ctx.putImageData(enhancedData, 0, 0);

        canvas.toBlob((blob) => {
          if (blob) {
            resolve({
              enhancedImage: new File([blob], file.name, { type: file.type }),
              qualityMetrics
            });
          } else {
            reject(new Error('Failed to enhance image'));
          }
        }, file.type, 0.95);
        
      } catch (error) {
        reject(error);
      }
    };

    img.onerror = () => reject(new Error('Failed to load image'));
    img.src = URL.createObjectURL(file);
  });
};

const assessImageQuality = (imageData: ImageData): any => {
  const data = imageData.data;
  const { width, height } = imageData;
  
  let contrast = 0;
  let brightness = 0;
  let sharpness = 0;
  
  // Calculate contrast and brightness
  for (let i = 0; i < data.length; i += 4) {
    const gray = 0.299 * data[i] + 0.587 * data[i + 1] + 0.114 * data[i + 2];
    brightness += gray;
  }
  brightness = brightness / (data.length / 4) / 255;
  
  // Calculate contrast using standard deviation
  let variance = 0;
  for (let i = 0; i < data.length; i += 4) {
    const gray = (0.299 * data[i] + 0.587 * data[i + 1] + 0.114 * data[i + 2]) / 255;
    variance += Math.pow(gray - brightness, 2);
  }
  contrast = Math.sqrt(variance / (data.length / 4));
  
  // Estimate sharpness using edge detection
  sharpness = calculateSharpness(imageData);
  
  const overallQuality = (
    Math.min(1, contrast * 2) * 30 +           // Contrast contribution (0-30)
    (1 - Math.abs(brightness - 0.5) * 2) * 30 + // Brightness contribution (0-30)
    Math.min(1, sharpness) * 40                 // Sharpness contribution (0-40)
  );
  
  return {
    contrast,
    brightness,
    sharpness,
    overallQuality,
    resolution: width * height
  };
};

const calculateSharpness = (imageData: ImageData): number => {
  const data = imageData.data;
  const { width, height } = imageData;
  
  let sharpness = 0;
  let count = 0;
  
  // Sample every 4th pixel for performance
  for (let y = 1; y < height - 1; y += 4) {
    for (let x = 1; x < width - 1; x += 4) {
      const i = (y * width + x) * 4;
      
      // Get grayscale values for 3x3 neighborhood
      const center = 0.299 * data[i] + 0.587 * data[i + 1] + 0.114 * data[i + 2];
      const right = 0.299 * data[i + 4] + 0.587 * data[i + 5] + 0.114 * data[i + 6];
      const bottom = 0.299 * data[i + width * 4] + 0.587 * data[i + width * 4 + 1] + 0.114 * data[i + width * 4 + 2];
      
      // Calculate gradient magnitude
      const gx = Math.abs(right - center);
      const gy = Math.abs(bottom - center);
      const gradient = Math.sqrt(gx * gx + gy * gy);
      
      sharpness += gradient;
      count++;
    }
  }
  
  return count > 0 ? (sharpness / count) / 255 : 0;
};

const applyAdaptiveEnhancement = (imageData: ImageData, quality: any): ImageData => {
  const data = imageData.data;
  const enhanced = new ImageData(new Uint8ClampedArray(data), imageData.width, imageData.height);
  const enhancedData = enhanced.data;
  
  // Adaptive parameters based on quality assessment
  const contrastBoost = quality.contrast < 0.3 ? 1.8 : 1.4;
  const gammaCorrection = quality.brightness < 0.4 ? 0.8 : quality.brightness > 0.7 ? 1.2 : 1.0;
  const sharpenStrength = quality.sharpness < 0.3 ? 0.5 : 0.2;
  
  for (let i = 0; i < data.length; i += 4) {
    const r = data[i];
    const g = data[i + 1];
    const b = data[i + 2];
    
    // Convert to grayscale with weighted average
    let gray = 0.299 * r + 0.587 * g + 0.114 * b;
    
    // Apply gamma correction
    gray = 255 * Math.pow(gray / 255, 1 / gammaCorrection);
    
    // Apply contrast enhancement
    gray = ((gray - 128) * contrastBoost + 128);
    
    // Apply adaptive thresholding for text
    const threshold = 140;
    if (gray > threshold) {
      gray = Math.min(255, gray * 1.1);
    } else {
      gray = Math.max(0, gray * 0.8);
    }
    
    // Clamp values
    gray = Math.max(0, Math.min(255, gray));
    
    enhancedData[i] = gray;
    enhancedData[i + 1] = gray;
    enhancedData[i + 2] = gray;
    enhancedData[i + 3] = data[i + 3]; // Preserve alpha
  }
  
  return enhanced;
};

// Enhanced color extraction with better performance and accuracy
const extractLogoColors = async (imageFile: File): Promise<ColorInfo[]> => {
  return new Promise((resolve) => {
    const canvas = document.createElement('canvas');
    const ctx = canvas.getContext('2d');
    if (!ctx) {
      resolve([]);
      return;
    }

    const img = new Image();
    img.onload = () => {
      try {
        // Optimize canvas size for color extraction
        const maxSize = 400; // Smaller size for faster processing
        let { width, height } = img;
        
        if (width > maxSize || height > maxSize) {
          const ratio = Math.min(maxSize / width, maxSize / height);
          width = Math.round(width * ratio);
          height = Math.round(height * ratio);
        }
        
        canvas.width = width;
        canvas.height = height;
        ctx.drawImage(img, 0, 0, width, height);

        const imageData = ctx.getImageData(0, 0, width, height);
        const colors = extractDominantColors(imageData);
        
        resolve(colors);
      } catch (error) {
        console.error('Color extraction failed:', error);
        resolve([]);
      }
    };

    img.onerror = () => resolve([]);
    img.src = URL.createObjectURL(imageFile);
  });
};

const extractDominantColors = (imageData: ImageData): ColorInfo[] => {
  const data = imageData.data;
  const colorMap = new Map<string, { count: number; positions: number[] }>();
  const { width, height } = imageData;
  
  // Strategic sampling - focus on areas where logos typically appear
  const regions = [
    { x: 0, y: 0, weight: 2 },                    // Top-left corner
    { x: width * 0.7, y: 0, weight: 2 },         // Top-right corner  
    { x: 0, y: height * 0.8, weight: 1.5 },      // Bottom-left
    { x: width * 0.3, y: height * 0.1, weight: 3 } // Upper center
  ];
  
  for (const region of regions) {
    const startX = Math.max(0, region.x - width * 0.15);
    const endX = Math.min(width, region.x + width * 0.15);
    const startY = Math.max(0, region.y - height * 0.15);
    const endY = Math.min(height, region.y + height * 0.15);
    
    for (let y = startY; y < endY; y += 3) {
      for (let x = startX; x < endX; x += 3) {
        const i = (Math.floor(y) * width + Math.floor(x)) * 4;
        const r = data[i];
        const g = data[i + 1];
        const b = data[i + 2];
        const a = data[i + 3];


// Also to Improve ocr to qR
Looking at your OCRToQRGenerator component, I can see it's well-structured but there are several areas where the OCR data handling can be improved. Let me break down the key improvement areas and provide specific code snippets for the complex parts.
Key Areas for Improvement
1. Enhanced OCR Data Validation & Confidence Handling
Your current validation is basic. You need more sophisticated validation that considers OCR confidence levels.
2. Better Phone Number Processing
The phone parsing logic is complex and could be more robust.
3. Smart Field Mapping & Fallbacks
Need better handling when OCR returns multiple possible values for the same field.
4. Data Normalization & Cleanup
OCR often returns messy data that needs cleaning before use.
Specific Improvements with Code Snippets
1. Enhanced OCR Result ProcessingEnhanced OCR Data ProcessorCode // Enhanced OCR data processing utilities
interface OCRRawData {
  texts: Array<{
    text: string;
    confidence: number;
    bbox: { x: number; y: number; width: number; height: number };
    field?: string;
  }>;
  logoColors?: Array<{ hex: strin2. Enhanced Contact Validation with OCR ContextEnhanced Contact Validator with OCR ContextCode // Enhanced contact validation that considers OCR confidence levels
interface ValidationResult {
  isValid: boolean;
  errors: string[];
  warnings: string[];
  suggestions: string[];
  fieldReliability: Record<string, 'high' | 'medium' | 'low'>;
}

3. Integration Code for Your Component
Here's how to integrate these improvements into your existing component:
//1
// Enhanced OCR data processing utilities
interface OCRRawData {
  texts: Array<{
    text: string;
    confidence: number;
    bbox: { x: number; y: number; width: number; height: number };
    field?: string;
  }>;
  logoColors?: Array<{ hex: string; rgb: string; frequency: number }>;
  overallConfidence: number;
}

interface ProcessedOCRData extends Contact {
  confidence: number;
  logoColors?: Array<{ hex: string; rgb: string; frequency: number }>;
  rawData: OCRRawData;
  fieldConfidences: Record<string, number>;
  alternativeValues: Record<string, string[]>;
}

class OCRDataProcessor {
  private emailRegex = /^[^\s@]+@[^\s@]+\.[^\s@]+$/;
  private phoneRegex = /[\+]?[\d\s\-\(\)\.]{7,15}/g;
  private urlRegex = /(?:https?:\/\/)?(?:www\.)?[a-zA-Z0-9-]+\.[a-zA-Z]{2,}(?:\/[^\s]*)?/g;
  
  // Enhanced phone number patterns
  private phonePatterns = {
    mobile: /(\+?\d{1,3}[-.\s]?)?\(?\d{3}\)?[-.\s]?\d{3}[-.\s]?\d{4}/,
    international: /\+\d{1,3}[-.\s]?\d{1,14}([-.\s]?\d{1,13})?/,
    extensions: /(ext|extension|x)\.?\s*\d{1,5}/i
  };

  processOCRData(rawData: OCRRawData): ProcessedOCRData {
    const fieldConfidences: Record<string, number> = {};
    const alternativeValues: Record<string, string[]> = {};
    
    // Group texts by field type and confidence
    const fieldGroups = this.groupTextsByField(rawData.texts);
    
    // Process each field with confidence weighting
    const processedContact: Contact = {
      name: this.extractBestValue(fieldGroups.name || [], fieldConfidences, 'name'),
      email: this.extractBestEmail(fieldGroups.email || [], fieldConfidences, alternativeValues),
      phone: this.extractBestPhone(fieldGroups.phone || [], fieldConfidences, alternativeValues),
      organization: this.extractBestValue(fieldGroups.organization || [], fieldConfidences, 'organization'),
      title: this.extractBestValue(fieldGroups.title || [], fieldConfidences, 'title'),
      website: this.extractBestWebsite(fieldGroups.website || [], fieldConfidences, alternativeValues),
      address: this.extractBestAddress(fieldGroups.address || [], fieldConfidences),
      // Enhanced phone number extraction
      mobilePhone: this.extractPhoneByType(fieldGroups.phone || [], 'mobile'),
      workPhone: this.extractPhoneByType(fieldGroups.phone || [], 'work'),
      homePhone: this.extractPhoneByType(fieldGroups.phone || [], 'home'),
      faxPhone: this.extractPhoneByType(fieldGroups.phone || [], 'fax'),
      message1: '',
      message2: ''
    };

    // Split name into first/last if not already done
    if (processedContact.name && !processedContact.firstName && !processedContact.lastName) {
      const nameParts = this.splitName(processedContact.name);
      processedContact.firstName = nameParts.firstName;
      processedContact.lastName = nameParts.lastName;
    }

    return {
      ...processedContact,
      confidence: rawData.overallConfidence,
      logoColors: rawData.logoColors,
      rawData,
      fieldConfidences,
      alternativeValues
    };
  }

  private groupTextsByField(texts: OCRRawData['texts']) {
    const groups: Record<string, OCRRawData['texts']> = {};
    
    texts.forEach(text => {
      const fieldType = this.classifyText(text.text);
      if (!groups[fieldType]) groups[fieldType] = [];
      groups[fieldType].push(text);
    });
    
    return groups;
  }

  private classifyText(text: string): string {
    const cleaned = text.trim().toLowerCase();
    
    // Email detection
    if (this.emailRegex.test(text)) return 'email';
    
    // Phone detection
    if (this.phoneRegex.test(text)) return 'phone';
    
    // Website detection
    if (this.urlRegex.test(text)) return 'website';
    
    // Title keywords
    const titleKeywords = ['ceo', 'cto', 'manager', 'director', 'president', 'vice', 'senior', 'lead', 'head', 'chief'];
    if (titleKeywords.some(keyword => cleaned.includes(keyword))) return 'title';
    
    // Organization indicators
    const orgKeywords = ['inc', 'llc', 'corp', 'company', 'ltd', 'co.', 'group', 'solutions', 'services'];
    if (orgKeywords.some(keyword => cleaned.includes(keyword))) return 'organization';
    
    // Address indicators
    const addressKeywords = ['street', 'st', 'avenue', 'ave', 'road', 'rd', 'suite', 'floor', 'building'];
    if (addressKeywords.some(keyword => cleaned.includes(keyword))) return 'address';
    
    // Default to name if it looks like a person's name
    if (this.looksLikeName(text)) return 'name';
    
    return 'unknown';
  }

  private looksLikeName(text: string): boolean {
    const words = text.trim().split(/\s+/);
    if (words.length < 1 || words.length > 4) return false;
    
    // Check if words start with capital letters and contain only letters
    return words.every(word => /^[A-Z][a-z]+$/.test(word));
  }

  private extractBestValue(
    candidates: OCRRawData['texts'], 
    confidences: Record<string, number>, 
    fieldName: string
  ): string {
    if (candidates.length === 0) return '';
    
    // Sort by confidence and length (longer is often better for names/titles)
    const sorted = candidates.sort((a, b) => {
      const confDiff = b.confidence - a.confidence;
      if (Math.abs(confDiff) < 10) { // If confidence is similar, prefer longer text
        return b.text.length - a.text.length;
      }
      return confDiff;
    });
    
    const best = sorted[0];
    confidences[fieldName] = best.confidence;
    return best.text.trim();
  }

  private extractBestEmail(
    candidates: OCRRawData['texts'], 
    confidences: Record<string, number>, 
    alternatives: Record<string, string[]>
  ): string {
    const emailCandidates = candidates.filter(c => this.emailRegex.test(c.text));
    if (emailCandidates.length === 0) return '';
    
    // Sort by confidence
    emailCandidates.sort((a, b) => b.confidence - a.confidence);
    
    const best = emailCandidates[0];
    confidences.email = best.confidence;
    
    // Store alternatives
    if (emailCandidates.length > 1) {
      alternatives.email = emailCandidates.slice(1).map(c => c.text.trim());
    }
    
    return best.text.trim().toLowerCase();
  }

  private extractBestPhone(
    candidates: OCRRawData['texts'], 
    confidences: Record<string, number>, 
    alternatives: Record<string, string[]>
  ): string {
    const phoneCandidates = candidates.filter(c => this.phoneRegex.test(c.text));
    if (phoneCandidates.length === 0) return '';
    
    // Clean and normalize phone numbers
    const cleanedPhones = phoneCandidates.map(c => ({
      ...c,
      cleaned: this.normalizePhoneNumber(c.text)
    }));
    
    // Remove duplicates
    const uniquePhones = cleanedPhones.filter((phone, index, array) => 
      array.findIndex(p => p.cleaned === phone.cleaned) === index
    );
    
    // Sort by confidence
    uniquePhones.sort((a, b) => b.confidence - a.confidence);
    
    const best = uniquePhones[0];
    confidences.phone = best.confidence;
    
    // Store alternatives and combine if multiple
    if (uniquePhones.length > 1) {
      alternatives.phone = uniquePhones.slice(1).map(p => p.cleaned);
      // Combine multiple phones with separator
      return uniquePhones.map(p => p.cleaned).join(' | ');
    }
    
    return best.cleaned;
  }

  private extractPhoneByType(candidates: OCRRawData['texts'], type: 'mobile' | 'work' | 'home' | 'fax'): string {
    const phoneCandidates = candidates.filter(c => this.phoneRegex.test(c.text));
    
    for (const candidate of phoneCandidates) {
      const text = candidate.text.toLowerCase();
      
      switch (type) {
        case 'mobile':
          if (text.includes('mobile') || text.includes('cell') || text.includes('m:')) {
            return this.normalizePhoneNumber(candidate.text);
          }
          break;
        case 'work':
          if (text.includes('work') || text.includes('office') || text.includes('t:')) {
            return this.normalizePhoneNumber(candidate.text);
          }
          break;
        case 'fax':
          if (text.includes('fax') || text.includes('f:')) {
            return this.normalizePhoneNumber(candidate.text);
          }
          break;
        case 'home':
          if (text.includes('home') || text.includes('h:')) {
            return this.normalizePhoneNumber(candidate.text);
          }
          break;
      }
    }
    
    return '';
  }

  private normalizePhoneNumber(phone: string): string {
    // Remove common prefixes
    let cleaned = phone.replace(/^[A-Za-z]+:?\s*/, '');
    
    // Extract just the phone number
    const match = cleaned.match(this.phonePatterns.international) || 
                  cleaned.match(this.phonePatterns.mobile);
    
    if (match) {
      cleaned = match[0];
    }
    
    // Clean up formatting but keep readable
    return cleaned.replace(/[^\d\+\-\(\)\s\.]/g, '').trim();
  }

  private extractBestWebsite(
    candidates: OCRRawData['texts'], 
    confidences: Record<string, number>, 
    alternatives: Record<string, string[]>
  ): string {
    const urlCandidates = candidates.filter(c => this.urlRegex.test(c.text));
    if (urlCandidates.length === 0) return '';
    
    // Clean and validate URLs
    const cleanedUrls = urlCandidates.map(c => ({
      ...c,
      cleaned: this.normalizeUrl(c.text)
    })).filter(c => c.cleaned);
    
    if (cleanedUrls.length === 0) return '';
    
    // Sort by confidence
    cleanedUrls.sort((a, b) => b.confidence - a.confidence);
    
    const best = cleanedUrls[0];
    confidences.website = best.confidence;
    
    if (cleanedUrls.length > 1) {
      alternatives.website = cleanedUrls.slice(1).map(u => u.cleaned);
    }
    
    return best.cleaned;
  }

  private normalizeUrl(url: string): string {
    let cleaned = url.trim();
    
    // Remove common prefixes that aren't part of URL
    cleaned = cleaned.replace(/^(website|url|web):\s*/i, '');
    
    // Add protocol if missing
    if (!/^https?:\/\//.test(cleaned) && /^www\.|^[a-zA-Z0-9-]+\.[a-zA-Z]{2,}/.test(cleaned)) {
      cleaned = 'https://' + cleaned;
    }
    
    return cleaned;
  }

  private extractBestAddress(candidates: OCRRawData['texts'], confidences: Record<string, number>): string {
    if (candidates.length === 0) return '';
    
    // Combine address parts that are likely on separate lines
    const addressParts = candidates
      .sort((a, b) => a.bbox.y - b.bbox.y) // Sort by vertical position
      .map(c => c.text.trim())
      .filter(text => text.length > 0);
    
    const combined = addressParts.join(', ');
    
    // Calculate average confidence
    const avgConfidence = candidates.reduce((sum, c) => sum + c.confidence, 0) / candidates.length;
    confidences.address = avgConfidence;
    
    return combined;
  }

  private splitName(fullName: string): { firstName: string; lastName: string } {
    const parts = fullName.trim().split(/\s+/);
    
    if (parts.length === 1) {
      return { firstName: parts[0], lastName: '' };
    } else if (parts.length === 2) {
      return { firstName: parts[0], lastName: parts[1] };
    } else {
      // For more than 2 parts, first word is firstName, rest is lastName
      return { 
        firstName: parts[0], 
        lastName: parts.slice(1).join(' ') 
      };
    }
  }
}

export default OCRDataProcessor;
//2
// Enhanced contact validation that considers OCR confidence levels
interface ValidationResult {
  isValid: boolean;
  errors: string[];
  warnings: string[];
  suggestions: string[];
  fieldReliability: Record<string, 'high' | 'medium' | 'low'>;
}

interface OCRContactData extends Contact {
  confidence: number;
  fieldConfidences: Record<string, number>;
  alternativeValues: Record<string, string[]>;
}

class EnhancedContactValidator {
  private emailRegex = /^[^\s@]+@[^\s@]+\.[^\s@]+$/;
  private phoneRegex = /^[\+]?[\d\s\-\(\)\.]{7,15}$/;
  private urlRegex = /^https?:\/\/[^\s/$.?#].[^\s]*$/i;

  validateOCRContact(contact: OCRContactData): ValidationResult {
    const errors: string[] = [];
    const warnings: string[] = [];
    const suggestions: string[] = [];
    const fieldReliability: Record<string, 'high' | 'medium' | 'low'> = {};

    // Check overall OCR confidence
    if (contact.confidence < 50) {
      warnings.push(`Low OCR confidence (${contact.confidence}%). Please review all fields carefully.`);
    }

    // Validate and assess each field
    this.validateName(contact, errors, warnings, suggestions, fieldReliability);
    this.validateEmail(contact, errors, warnings, suggestions, fieldReliability);
    this.validatePhone(contact, errors, warnings, suggestions, fieldReliability);
    this.validateWebsite(contact, errors, warnings, suggestions, fieldReliability);
    this.validateOrganizationAndTitle(contact, errors, warnings, suggestions, fieldReliability);

    // Cross-field validation
    this.performCrossFieldValidation(contact, warnings, suggestions);

    // Suggest improvements based on alternatives
    this.suggestAlternatives(contact, suggestions);

    return {
      isValid: errors.length === 0,
      errors,
      warnings,
      suggestions,
      fieldReliability
    };
  }

  private validateName(
    contact: OCRContactData, 
    errors: string[], 
    warnings: string[], 
    suggestions: string[],
    reliability: Record<string, 'high' | 'medium' | 'low'>
  ) {
    const nameConfidence = contact.fieldConfidences.name || 0;
    
    if (!contact.name && !contact.firstName && !contact.lastName) {
      errors.push('Name is required');
      return;
    }

    // Assess name reliability
    if (nameConfidence > 80) {
      reliability.name = 'high';
    } else if (nameConfidence > 60) {
      reliability.name = 'medium';
      warnings.push(`Name field has moderate confidence (${nameConfidence}%). Please verify spelling.`);
    } else {
      reliability.name = 'low';
      warnings.push(`Name field has low confidence (${nameConfidence}%). Please check for accuracy.`);
    }

    // Check for common OCR errors in names
    const fullName = contact.name || `${contact.firstName} ${contact.lastName}`.trim();
    if (this.hasCommonOCRErrors(fullName)) {
      warnings.push('Name may contain OCR recognition errors (unusual characters or spacing)');
      suggestions.push('Check for incorrect characters like "0" instead of "O" or "1" instead of "l"');
    }

    // Check name format
    if (fullName.length < 2) {
      warnings.push('Name seems unusually short');
    }
    
    if (fullName.length > 50) {
      warnings.push('Name seems unusually long - may include title or organization');
    }

    // Check for title mixed with name
    const titleKeywords = ['ceo', 'cto', 'manager', 'director', 'president'];
    if (titleKeywords.some(title => fullName.toLowerCase().includes(title))) {
      suggestions.push('Name field may contain job title - consider moving to title field');
    }
  }

  private validateEmail(
    contact: OCRContactData,
    errors: string[],
    warnings: string[],
    suggestions: string[],
    reliability: Record<string, 'high' | 'medium' | 'low'>
  ) {
    if (!contact.email) {
      warnings.push('Email address not found - this will limit contact sharing options');
      return;
    }

    const emailConfidence = contact.fieldConfidences.email || 0;

    // Basic email validation
    if (!this.emailRegex.test(contact.email)) {
      errors.push('Email address format is invalid');
      reliability.email = 'low';
      return;
    }

    // Assess email reliability based on OCR confidence
    if (emailConfidence > 85) {
      reliability.email = 'high';
    } else if (emailConfidence > 70) {
      reliability.email = 'medium';
      warnings.push(`Email field has moderate confidence (${emailConfidence}%). Please verify spelling.`);
    } else {
      reliability.email = 'low';
      warnings.push(`Email field has low confidence (${emailConfidence}%). Please double-check accuracy.`);
    }

    // Check for common OCR email errors
    if (this.hasCommonEmailOCRErrors(contact.email)) {
      warnings.push('Email may contain OCR errors (check @ symbol and domain)');
      suggestions.push('Common OCR email errors: "rn" → "m", "cl" → "d", "0" → "o"');
    }

    // Validate domain
    const domain = contact.email.split('@')[1];
    if (domain && !this.isValidDomain(domain)) {
      warnings.push('Email domain appears unusual - please verify');
    }
  }

  private validatePhone(
    contact: OCRContactData,
    errors: string[],
    warnings: string[],
    suggestions: string[],
    reliability: Record<string, 'high' | 'medium' | 'low'>
  ) {
    const phoneNumbers = [
      contact.phone,
      contact.mobilePhone,
      contact.workPhone,
      contact.homePhone,
      contact.faxPhone
    ].filter(Boolean);

    if (phoneNumbers.length === 0) {
      warnings.push('No phone numbers found - this will limit contact options');
      return;
    }

    const phoneConfidence = contact.fieldConfidences.phone || 0;

    // Validate each phone number
    let hasValidPhone = false;
    phoneNumbers.forEach((phone, index) => {
      const cleanPhone = phone.replace(/[^\d\+]/g, '');
      
      if (cleanPhone.length < 7) {
        warnings.push(`Phone number ${index + 1} seems too short`);
      } else if (cleanPhone.length > 15) {
        warnings.push(`Phone number ${index + 1} seems too long`);
      } else {
        hasValidPhone = true;
      }

      // Check for common OCR phone errors
      if (this.hasCommonPhoneOCRErrors(phone)) {
        warnings.push(`Phone number ${index + 1} may contain OCR errors`);
        suggestions.push('Common phone OCR errors: "S" → "5", "O" → "0", "I" → "1"');
      }
    });

    // Assess phone reliability
    if (phoneConfidence > 80 && hasValidPhone) {
      reliability.phone = 'high';
    } else if (phoneConfidence > 60 && hasValidPhone) {
      reliability.phone = 'medium';
      warnings.push(`Phone field has moderate confidence (${phoneConfidence}%). Please verify numbers.`);
    } else {
      reliability.phone = 'low';
      warnings.push(`Phone field has low confidence (${phoneConfidence}%). Please check all digits.`);
    }

    if (!hasValidPhone) {
      errors.push('At least one valid phone number is required');
    }
  }

  private validateWebsite(
    contact: OCRContactData,
    errors: string[],
    warnings: string[],
    suggestions: string[],
    reliability: Record<string, 'high' | 'medium' | 'low'>
  ) {
    if (!contact.website) return;

    const websiteConfidence = contact.fieldConfidences.website || 0;

    // Basic URL validation
    if (!this.urlRegex.test(contact.website) && !this.isValidDomain(contact.website)) {
      warnings.push('Website URL format may be incorrect');
      reliability.website = 'low';
    } else {
      // Assess website reliability
      if (websiteConfidence > 80) {
        reliability.website = 'high';
      } else if (websiteConfidence > 60) {
        reliability.website = 'medium';
        warnings.push(`Website field has moderate confidence (${websiteConfidence}%). Please verify URL.`);
      } else {
        reliability.website = 'low';
        warnings.push(`Website field has low confidence (${websiteConfidence}%). Please check spelling.`);
      }
    }

    // Check for common website OCR errors
    if (this.hasCommonWebsiteOCRErrors(contact.website)) {
      warnings.push('Website URL may contain OCR errors');
      suggestions.push('Common website OCR errors: "rn" → "m", "." → ",", "0" → "o"');
    }
  }

  private validateOrganizationAndTitle(
    contact: OCRContactData,
    errors: string[],
    warnings: string[],
    suggestions: string[],
    reliability: Record<string, 'high' | 'medium' | 'low'>
  ) {
    // Validate organization
    if (contact.organization) {
      const orgConfidence = contact.fieldConfidences.organization || 0;
      
      if (orgConfidence > 75) {
        reliability.organization = 'high';
      } else if (orgConfidence > 50) {
        reliability.organization = 'medium';
        warnings.push(`Organization field has moderate confidence (${orgConfidence}%).`);
      } else {
        reliability.organization = 'low';
        warnings.push(`Organization field has low confidence (${orgConfidence}%).`);
      }
    }

    // Validate title
    if (contact.title) {
      const titleConfidence = contact.fieldConfidences.title || 0;
      
      if (titleConfidence > 75) {
        reliability.title = 'high';
      } else if (titleConfidence > 50) {
        reliability.title = 'medium';
        warnings.push(`Title field has moderate confidence (${titleConfidence}%).`);
      } else {
        reliability.title = 'low';
        warnings.push(`Title field has low confidence (${titleConfidence}%).`);
      }
    }
  }

  private performCrossFieldValidation(
    contact: OCRContactData,
    warnings: string[],
    suggestions: string[]
  ) {
    // Check if email domain matches organization
    if (contact.email && contact.organization) {
      const emailDomain = contact.email.split('@')[1]?.toLowerCase();
      const orgName = contact.organization.toLowerCase().replace(/[^a-z0-9]/g, '');
      
      if (emailDomain && !emailDomain.includes(orgName.substring(0, 6))) {
        suggestions.push('Email domain doesn\'t match organization - verify both are correct');
      }
    }

    // Check name consistency
    if (contact.name && contact.firstName && contact.lastName) {
      const fullNameFromParts = `${contact.firstName} ${contact.lastName}`.trim();
      if (contact.name.toLowerCase() !== fullNameFromParts.toLowerCase()) {
        warnings.push('Name field inconsistent with first/last name fields');
        suggestions.push('Choose either full name OR first/last name fields, not both');
      }
    }
  }

  private suggestAlternatives(contact: OCRContactData, suggestions: string[]) {
    if (contact.alternativeValues) {
      Object.entries(contact.alternativeValues).forEach(([field, alternatives]) => {
        if (alternatives.length > 0) {
          suggestions.push(`Alternative ${field} values found: ${alternatives.join(', ')}`);
        }
      });
    }
  }

  // Helper methods for OCR error detection
  private hasCommonOCRErrors(text: string): boolean {
    // Check for common OCR character confusion
    const suspiciousPatterns = [
      /[0O]{2,}/, // Multiple zeros/Os together
      /[1Il]{2,}/, // Multiple 1/I/l together
      /[rn]/g, // rn that might be m
      /\s{2,}/, // Multiple spaces
      /[^\w\s\-\.']/g // Unusual characters for names
    ];
    
    return suspiciousPatterns.some(pattern => pattern.test(text));
  }

  private hasCommonEmailOCRErrors(email: string): boolean {
    return /[rn]n|[cl]d|[0O][a-z]|[@]{2,}|[\.]{2,}/.test(email);
  }

  private hasCommonPhoneOCRErrors(phone: string): boolean {
    return /[OS][0-9]|[I1][0-9]|[rn][0-9]/.test(phone);
  }

  private hasCommonWebsiteOCRErrors(website: string): boolean {
    return /[rn]n|[cl]om|[0O][a-z]|[\.]{2,}|[,]/.test(website);
  }

  private isValidDomain(domain: string): boolean {
    return /^[a-zA-Z0-9][a-zA-Z0-9-]{1,61}[a-zA-Z0-9]\.[a-zA-Z]{2,}$/.test(domain);
  }
}

export default EnhancedContactValidator;
//3
// Integration code to replace parts of your existing OCRToQRGenerator component

// 1. Add these imports at the top
import OCRDataProcessor from './utils/OCRDataProcessor';
import EnhancedContactValidator from './utils/EnhancedContactValidator';

// 2. Add these state variables to your component
const [validationResult, setValidationResult] = useState<{
  isValid: boolean;
  errors: string[];
  warnings: string[];
  suggestions: string[];
  fieldReliability: Record<string, 'high' | 'medium' | 'low'>;
} | null>(null);

const [processedOCRData, setProcessedOCRData] = useState<ProcessedOCRData | null>(null);

// 3. Initialize processors
const ocrProcessor = new OCRDataProcessor();
const contactValidator = new EnhancedContactValidator();

// 4. Replace your handleImageUpload function with this enhanced version
const handleImageUpload = useCallback(async (event: React.ChangeEvent<HTMLInputElement>) => {
  const file = event.target.files?.[0];
  if (!file) return;

  if (!file.type.startsWith('image/')) {
    setScanError('Please select a valid image file');
    return;
  }

  if (file.size > 10 * 1024 * 1024) {
    setScanError('Image file size must be less than 10MB');
    return;
  }

  setScanError(null);
  setIsScanning(true);

  try {
    const imageUrl = URL.createObjectURL(file);
    setUploadedImage(imageUrl);

    // Your existing OCR scanning
    const rawOCRData = await scanBusinessCar

    //Take ideas from these all to enhance and optimize our code i think ther are duplicate lines since you kept adding code again and again.
    