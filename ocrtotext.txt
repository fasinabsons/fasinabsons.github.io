# OCR to QR Code Scanner Enhancement Guide

## Step 1: Enhanced OCR Text Detection & Field Extraction

### 1.1 Improve Image Preprocessing
```typescript
// Enhanced image preprocessing function
export const enhancedPreprocessImage = async (file: File): Promise<File> => {
  return new Promise((resolve, reject) => {
    const canvas = document.createElement('canvas');
    const ctx = canvas.getContext('2d');
    const img = new Image();
    
    img.onload = () => {
      // Set optimal canvas size
      const maxSize = 1200;
      const scale = Math.min(maxSize / img.width, maxSize / img.height);
      canvas.width = img.width * scale;
      canvas.height = img.height * scale;
      
      // Apply image enhancements
      ctx.drawImage(img, 0, 0, canvas.width, canvas.height);
      
      // Apply filters for better OCR
      const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
      const data = imageData.data;
      
      // Increase contrast and brightness
      for (let i = 0; i < data.length; i += 4) {
        // Contrast enhancement
        data[i] = Math.min(255, Math.max(0, (data[i] - 128) * 1.5 + 128));     // Red
        data[i + 1] = Math.min(255, Math.max(0, (data[i + 1] - 128) * 1.5 + 128)); // Green
        data[i + 2] = Math.min(255, Math.max(0, (data[i + 2] - 128) * 1.5 + 128)); // Blue
        
        // Sharpen filter
        const brightness = (data[i] + data[i + 1] + data[i + 2]) / 3;
        if (brightness > 128) {
          data[i] = Math.min(255, data[i] + 20);
          data[i + 1] = Math.min(255, data[i + 1] + 20);
          data[i + 2] = Math.min(255, data[i + 2] + 20);
        }
      }
      
      ctx.putImageData(imageData, 0, 0);
      
      canvas.toBlob((blob) => {
        if (blob) {
          const processedFile = new File([blob], file.name, { type: 'image/jpeg' });
          resolve(processedFile);
        } else {
          reject(new Error('Failed to process image'));
        }
      }, 'image/jpeg', 0.9);
    };
    
    img.onerror = () => reject(new Error('Failed to load image'));
    img.src = URL.createObjectURL(file);
  });
};
```

### 1.2 Advanced Text Extraction with Multiple OCR Engines
```typescript
// Multi-engine OCR approach
export const multiEngineOCR = async (file: File): Promise<string[]> => {
  const results: string[] = [];
  
  // Tesseract.js for primary OCR
  try {
    const { data: { text } } = await Tesseract.recognize(file, 'eng', {
      logger: m => console.log(m),
      tessedit_char_whitelist: '0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz@.-+()[]{}:;,<>/?|\\~`!#$%^&*_= \n\t',
      tessedit_pageseg_mode: Tesseract.PSM.AUTO_OSD,
      tessedit_ocr_engine_mode: Tesseract.OEM.LSTM_ONLY
    });
    results.push(text);
  } catch (error) {
    console.error('Tesseract OCR failed:', error);
  }
  
  // Google Vision API alternative (if available)
  try {
    const visionResult = await callGoogleVisionAPI(file);
    if (visionResult) results.push(visionResult);
  } catch (error) {
    console.error('Google Vision OCR failed:', error);
  }
  
  return results;
};
```

### 1.3 Smart Field Detection with Regex Patterns
```typescript
// Enhanced field detection patterns
export const FIELD_PATTERNS = {
  email: [
    /([a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,})/gi,
    /\b[A-Za-z0-9._%+-]+@[A-Za-z0-9.-]+\.[A-Z|a-z]{2,}\b/gi
  ],
  phone: [
    /(\+?1?[-.\s]?)?\(?([0-9]{3})\)?[-.\s]?([0-9]{3})[-.\s]?([0-9]{4})/g,
    /(\+\d{1,3}[-.\s]?)?\(?([0-9]{2,4})\)?[-.\s]?([0-9]{3,4})[-.\s]?([0-9]{3,4})/g,
    /(\+?971[-.\s]?)?(\d{2})[-.\s]?(\d{3})[-.\s]?(\d{4})/g, // UAE format
    /(\+?971[-.\s]?)?(\d{1})[-.\s]?(\d{3})[-.\s]?(\d{4})/g  // UAE mobile
  ],
  website: [
    /(https?:\/\/)?(www\.)?[-a-zA-Z0-9@:%._\+~#=]{1,256}\.[a-zA-Z0-9()]{1,6}\b([-a-zA-Z0-9()@:%_\+.~#?&//=]*)/gi,
    /\b(?:www\.)?[a-zA-Z0-9-]+\.[a-zA-Z]{2,}\b/gi
  ],
  name: [
    /^[A-Z][a-z]+\s+[A-Z][a-z]+(\s+[A-Z][a-z]+)*$/m, // Full name pattern
    /\b[A-Z][a-z]+\s+[A-Z][a-z]+\b/g // First Last name
  ],
  title: [
    /\b(CEO|CTO|CFO|Manager|Director|Engineer|Developer|Designer|Analyst|Consultant|Specialist|Coordinator|Assistant|Executive|President|Vice President|Senior|Junior|Lead|Principal|Chief)\b/gi
  ],
  company: [
    /\b(LLC|Inc|Corp|Ltd|Company|Group|Solutions|Services|Technologies|Systems|Consulting|International|Global|Holdings|Partners|Associates|Enterprises|Industries)\b/gi
  ]
};

// Enhanced field extraction
export const extractFieldsFromText = (texts: string[]): Partial<Contact> => {
  const contact: Partial<Contact> = {};
  const allText = texts.join('\n');
  const lines = allText.split('\n').filter(line => line.trim().length > 0);
  
  // Extract emails (multiple)
  const emails = new Set<string>();
  FIELD_PATTERNS.email.forEach(pattern => {
    const matches = allText.match(pattern);
    if (matches) {
      matches.forEach(email => emails.add(email.toLowerCase()));
    }
  });
  
  // Extract phone numbers (multiple)
  const phones = new Set<string>();
  FIELD_PATTERNS.phone.forEach(pattern => {
    const matches = allText.match(pattern);
    if (matches) {
      matches.forEach(phone => {
        // Clean and format phone number
        const cleaned = phone.replace(/[^\d+]/g, '');
        if (cleaned.length >= 10) {
          phones.add(phone.trim());
        }
      });
    }
  });
  
  // Extract website
  const websites = new Set<string>();
  FIELD_PATTERNS.website.forEach(pattern => {
    const matches = allText.match(pattern);
    if (matches) {
      matches.forEach(website => {
        let cleanWebsite = website.toLowerCase();
        if (!cleanWebsite.startsWith('http')) {
          cleanWebsite = 'https://' + cleanWebsite;
        }
        websites.add(cleanWebsite);
      });
    }
  });
  
  // Extract name (smart detection)
  const names = new Set<string>();
  lines.forEach(line => {
    const trimmedLine = line.trim();
    // Check if line looks like a name (2-3 words, proper case)
    if (/^[A-Z][a-z]+(\s+[A-Z][a-z]+){1,2}$/.test(trimmedLine)) {
      names.add(trimmedLine);
    }
  });
  
  // Extract title
  const titles = new Set<string>();
  FIELD_PATTERNS.title.forEach(pattern => {
    const matches = allText.match(pattern);
    if (matches) {
      matches.forEach(title => titles.add(title));
    }
  });
  
  // Extract company
  const companies = new Set<string>();
  lines.forEach(line => {
    FIELD_PATTERNS.company.forEach(pattern => {
      if (pattern.test(line)) {
        companies.add(line.trim());
      }
    });
  });
  
  // Assign extracted data
  contact.email = Array.from(emails).slice(0, 2).join('; '); // First 2 emails
  contact.phone = Array.from(phones).slice(0, 3).join(' | '); // First 3 phone numbers
  contact.website = Array.from(websites)[0] || '';
  contact.name = Array.from(names)[0] || '';
  contact.title = Array.from(titles)[0] || '';
  contact.organization = Array.from(companies)[0] || '';
  
  return contact;
};
```

## Step 2: Logo Detection and Color Extraction

### 2.1 Logo Detection using Canvas Analysis
```typescript
// Logo detection and color extraction
export const detectLogoAndColors = async (file: File): Promise<{
  logoDetected: boolean;
  dominantColors: string[];
  logoArea?: { x: number; y: number; width: number; height: number };
}> => {
  return new Promise((resolve) => {
    const canvas = document.createElement('canvas');
    const ctx = canvas.getContext('2d');
    const img = new Image();
    
    img.onload = () => {
      canvas.width = img.width;
      canvas.height = img.height;
      ctx.drawImage(img, 0, 0);
      
      const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
      const data = imageData.data;
      
      // Color frequency analysis
      const colorMap = new Map<string, number>();
      const logoAreas: any[] = [];
      
      // Sample pixels for color analysis
      for (let i = 0; i < data.length; i += 16) { // Sample every 4th pixel
        const r = data[i];
        const g = data[i + 1];
        const b = data[i + 2];
        const a = data[i + 3];
        
        if (a > 200) { // Ignore transparent pixels
          const color = `rgb(${r},${g},${b})`;
          colorMap.set(color, (colorMap.get(color) || 0) + 1);
        }
      }
      
      // Get dominant colors (excluding white/near-white)
      const sortedColors = Array.from(colorMap.entries())
        .filter(([color, count]) => {
          const [r, g, b] = color.match(/\d+/g)!.map(Number);
          return !(r > 240 && g > 240 && b > 240); // Filter out white-ish colors
        })
        .sort((a, b) => b[1] - a[1])
        .slice(0, 5)
        .map(([color]) => color);
      
      // Convert to hex colors
      const hexColors = sortedColors.map(color => {
        const [r, g, b] = color.match(/\d+/g)!.map(Number);
        return `#${r.toString(16).padStart(2, '0')}${g.toString(16).padStart(2, '0')}${b.toString(16).padStart(2, '0')}`;
      });
      
      // Simple logo detection (areas with consistent non-white colors)
      const logoDetected = hexColors.length > 0 && 
        hexColors.some(color => {
          const [r, g, b] = color.match(/[0-9a-f]{2}/gi)!.map(hex => parseInt(hex, 16));
          return r + g + b < 600; // Has some non-white colors
        });
      
      resolve({
        logoDetected,
        dominantColors: hexColors,
        logoArea: logoDetected ? { x: 0, y: 0, width: canvas.width, height: canvas.height } : undefined
      });
    };
    
    img.onerror = () => resolve({ logoDetected: false, dominantColors: [] });
    img.src = URL.createObjectURL(file);
  });
};
```

### 2.2 Theme Color Application
```typescript
// Apply logo colors to QR code theme
export const applyLogoColorsToQR = (dominantColors: string[]): QRCodeStyle => {
  if (dominantColors.length === 0) {
    return {
      foregroundColor: '#000000',
      backgroundColor: '#ffffff',
      transparent: true,
      gradient: false,
      gradientColor: '#8b5cf6',
      borderRadius: 0
    };
  }
  
  const primaryColor = dominantColors[0];
  const secondaryColor = dominantColors[1] || primaryColor;
  
  return {
    foregroundColor: primaryColor,
    backgroundColor: '#ffffff',
    transparent: true,
    gradient: dominantColors.length > 1,
    gradientColor: secondaryColor,
    borderRadius: 8
  };
};
```

## Step 3: Enhanced Contact Data Structure

### 3.1 Extended Contact Interface
```typescript
// Enhanced contact interface
export interface EnhancedContact extends Contact {
  emails: string[]; // Multiple emails
  phones: PhoneNumber[]; // Multiple phone numbers with types
  websites: string[]; // Multiple websites
  socialMedia: SocialMediaLink[]; // Social media profiles
  logoColors: string[]; // Extracted logo colors
  confidence: number; // OCR confidence score
}

export interface PhoneNumber {
  number: string;
  type: 'mobile' | 'office' | 'home' | 'fax' | 'other';
  country?: string;
  formatted?: string;
}

export interface SocialMediaLink {
  platform: 'linkedin' | 'twitter' | 'facebook' | 'instagram' | 'other';
  url: string;
  username?: string;
}
```

### 3.2 Advanced vCard Generation
```typescript
// Enhanced vCard generation with multiple contacts
export const generateEnhancedVCard = (contact: EnhancedContact): string => {
  const nameComponents = contact.name.trim().split(/\s+/);
  const lastName = nameComponents.length > 1 ? nameComponents.pop() || '' : '';
  const firstName = nameComponents.join(' ');
  
  const vcard = [
    'BEGIN:VCARD',
    'VERSION:3.0',
    `FN:${contact.name}`,
    `N:${lastName};${firstName};;;`,
    contact.organization ? `ORG:${contact.organization}` : '',
    contact.title ? `TITLE:${contact.title}` : '',
    contact.address ? `ADR:;;${contact.address};;;;` : '',
    
    // Multiple emails
    ...contact.emails.map((email, index) => 
      `EMAIL${index === 0 ? '' : `;TYPE=WORK${index}`}:${email}`
    ),
    
    // Multiple phone numbers
    ...contact.phones.map((phone, index) => 
      `TEL;TYPE=${phone.type.toUpperCase()}:${phone.number}`
    ),
    
    // Multiple websites
    ...contact.websites.map((website, index) => 
      `URL${index === 0 ? '' : `;TYPE=WORK${index}`}:${website}`
    ),
    
    // Social media
    ...contact.socialMedia.map(social => 
      `URL;TYPE=${social.platform.toUpperCase()}:${social.url}`
    ),
    
    'END:VCARD'
  ].filter(Boolean);

  return vcard.join('\n');
};
```

## Step 4: Code Integration and Optimization

### 4.1 Update the Main Scanner Function
```typescript
// Enhanced scanner function in cardScanner.ts
export const enhancedScanBusinessCard = async (file: File): Promise<EnhancedContact> => {
  try {
    // Step 1: Preprocess image
    const processedFile = await enhancedPreprocessImage(file);
    
    // Step 2: Multi-engine OCR
    const ocrResults = await multiEngineOCR(processedFile);
    
    // Step 3: Extract fields
    const extractedFields = extractFieldsFromText(ocrResults);
    
    // Step 4: Detect logo and colors
    const logoData = await detectLogoAndColors(processedFile);
    
    // Step 5: Parse multiple emails and phones
    const emails = extractedFields.email ? 
      extractedFields.email.split(';').map(e => e.trim()).filter(e => e.length > 0) : [];
    
    const phoneStrings = extractedFields.phone ? 
      extractedFields.phone.split('|').map(p => p.trim()).filter(p => p.length > 0) : [];
    
    const phones: PhoneNumber[] = phoneStrings.map((phone, index) => ({
      number: phone,
      type: index === 0 ? 'office' : 'mobile',
      formatted: formatPhoneNumber(phone)
    }));
    
    const websites = extractedFields.website ? [extractedFields.website] : [];
    
    // Step 6: Calculate confidence score
    const confidence = calculateConfidenceScore(extractedFields, ocrResults);
    
    return {
      ...extractedFields,
      emails,
      phones,
      websites,
      socialMedia: [],
      logoColors: logoData.dominantColors,
      confidence,
      // Legacy fields for compatibility
      email: emails.join('; '),
      phone: phoneStrings.join(' | '),
      website: websites[0] || '',
      message1: '',
      message2: ''
    } as EnhancedContact;
    
  } catch (error) {
    console.error('Enhanced scanning failed:', error);
    throw new Error('Failed to scan business card with enhanced OCR');
  }
};

// Helper function to calculate confidence
const calculateConfidenceScore = (fields: any, ocrResults: string[]): number => {
  let score = 0;
  const totalFields = 7; // name, email, phone, company, title, website, address
  
  if (fields.name) score += 1;
  if (fields.email) score += 1;
  if (fields.phone) score += 1;
  if (fields.organization) score += 1;
  if (fields.title) score += 1;
  if (fields.website) score += 1;
  if (fields.address) score += 1;
  
  return Math.round((score / totalFields) * 100);
};
```

### 4.2 Update the Main Component
```typescript
// In OCRToQRGenerator.tsx, update the handleImageUpload function
const handleImageUpload = useCallback(async (event: React.ChangeEvent<HTMLInputElement>) => {
  const file = event.target.files?.[0];
  if (!file) return;

  if (!file.type.startsWith('image/')) {
    setScanError('Please select a valid image file');
    return;
  }

  if (file.size > 10 * 1024 * 1024) {
    setScanError('Image file size must be less than 10MB');
    return;
  }

  setScanError(null);
  setIsScanning(true);

  try {
    const imageUrl = URL.createObjectURL(file);
    setUploadedImage(imageUrl);

    // Use enhanced scanner
    const enhancedContact = await enhancedScanBusinessCard(file);
    
    // Apply logo colors to QR style
    const logoTheme = applyLogoColorsToQR(enhancedContact.logoColors);
    setQrStyle(logoTheme);
    
    // Convert to legacy format for compatibility
    const legacyContact: Contact = {
      name: enhancedContact.name || '',
      email: enhancedContact.emails.join('; '),
      phone: enhancedContact.phones.map(p => p.number).join(' | '),
      organization: enhancedContact.organization || '',
      title: enhancedContact.title || '',
      address: enhancedContact.address || '',
      website: enhancedContact.websites[0] || '',
      message1: '',
      message2: ''
    };

    setContact(legacyContact);
    setStep('edit');
    
    // Show confidence score
    if (enhancedContact.confidence < 70) {
      setScanError(`OCR confidence: ${enhancedContact.confidence}%. Please review the extracted information carefully.`);
    }
    
  } catch (error) {
    console.error('Enhanced OCR scanning failed:', error);
    setScanError('Failed to scan the business card. Please try again or enter details manually.');
  } finally {
    setIsScanning(false);
  }
}, []);
```

## Step 5: Installation and Dependencies

### 5.1 Required Dependencies
```bash
npm install tesseract.js canvas-confetti
npm install @types/canvas-confetti --save-dev
```

### 5.2 Enhanced Error Handling
```typescript
// Add to utils/errorHandler.ts
export class OCRError extends Error {
  public code: string;
  public confidence?: number;
  
  constructor(message: string, code: string, confidence?: number) {
    super(message);
    this.name = 'OCRError';
    this.code = code;
    this.confidence = confidence;
  }
}

export const handleOCRError = (error: any): string => {
  if (error instanceof OCRError) {
    switch (error.code) {
      case 'LOW_CONFIDENCE':
        return `OCR confidence is low (${error.confidence}%). Please review extracted data.`;
      case 'NO_TEXT_DETECTED':
        return 'No text detected in the image. Please ensure the image is clear and contains text.';
      case 'PROCESSING_FAILED':
        return 'Failed to process the image. Please try a different image or check the file format.';
      default:
        return error.message;
    }
  }
  return 'An unexpected error occurred during OCR processing.';
};
```

## Step 6: Testing and Validation

### 6.1 Test Cases
Create test cases for:
- Multiple phone numbers extraction
- Multiple email addresses
- Logo color detection
- Name recognition accuracy
- Website URL extraction
- Company name detection

### 6.2 Performance Optimization
- Implement image compression before OCR
- Add progress indicators for long-running operations
- Cache OCR results for repeated processing
- Optimize regex patterns for better performance

## Summary

This enhanced system provides:
1. **Multi-engine OCR** for better text extraction
2. **Smart field detection** with advanced regex patterns
3. **Logo detection and color extraction** for theme application
4. **Multiple contact field support** (emails, phones, websites)
5. **Enhanced error handling** with confidence scores
6. **Optimized performance** with image preprocessing
7. **Professional QR code generation** with logo-based themes

The system now handles complex business cards with multiple contact methods and applies extracted logo colors to create cohesive, professional QR code designs.

//Also extra ideas to enhanced
import React, { useState, useRef, useCallback } from 'react';
import { Camera, Upload, Download, Scan, Palette, QrCode } from 'lucide-react';

const AdvancedCardScanner = () => {
  const [image, setImage] = useState(null);
  const [isProcessing, setIsProcessing] = useState(false);
  const [extractedData, setExtractedData] = useState(null);
  const [logoColors, setLogoColors] = useState([]);
  const [qrCode, setQrCode] = useState(null);
  const fileInputRef = useRef(null);
  const canvasRef = useRef(null);

  // Enhanced OCR processing with Tesseract.js simulation
  const processBusinessCard = useCallback(async (imageFile) => {
    setIsProcessing(true);
    
    try {
      // Simulate advanced OCR processing
      await new Promise(resolve => setTimeout(resolve, 2000));
      
      // Extract logo colors first
      const colors = await extractLogoColors(imageFile);
      setLogoColors(colors);
      
      // Simulate OCR text extraction with high accuracy
      const mockExtractedData = {
        name: "Johnny Jabbour",
        nameArabic: "جوني جبور",
        title: "Business Development Manager",
        organization: "Sicuro",
        emails: ["johnny@sicurouae.ae"],
        phones: ["+971 50 219 1969", "+971 2 441 0590", "+971 2 441 0591"],
        address: "P.O Box 25475, Abu Dhabi, UAE",
        website: "sicurouae.ae",
        logoColors: colors,
        confidence: 98.5
      };
      
      setExtractedData(mockExtractedData);
      
      // Generate QR code with extracted colors
      const qrData = generateQRCode(mockExtractedData, colors[0]);
      setQrCode(qrData);
      
    } catch (error) {
      console.error('Processing failed:', error);
    } finally {
      setIsProcessing(false);
    }
  }, []);

  // Advanced color extraction from logo/brand elements
  const extractLogoColors = async (imageFile) => {
    return new Promise((resolve) => {
      const canvas = document.createElement('canvas');
      const ctx = canvas.getContext('2d');
      const img = new Image();
      
      img.onload = () => {
        canvas.width = img.width;
        canvas.height = img.height;
        ctx.drawImage(img, 0, 0);
        
        const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
        const colors = extractDominantColors(imageData);
        
        resolve(colors);
      };
      
      img.src = URL.createObjectURL(imageFile);
    });
  };

  // K-means clustering for dominant color extraction
  const extractDominantColors = (imageData) => {
    const data = imageData.data;
    const pixels = [];
    
    // Sample pixels (every 4th pixel for performance)
    for (let i = 0; i < data.length; i += 16) {
      const r = data[i];
      const g = data[i + 1];
      const b = data[i + 2];
      const a = data[i + 3];
      
      // Skip transparent and very light/dark pixels
      if (a > 128 && (r + g + b) > 50 && (r + g + b) < 700) {
        pixels.push([r, g, b]);
      }
    }
    
    // Simple color clustering
    const colorCounts = {};
    pixels.forEach(([r, g, b]) => {
      // Quantize colors to reduce noise
      const qR = Math.floor(r / 32) * 32;
      const qG = Math.floor(g / 32) * 32;
      const qB = Math.floor(b / 32) * 32;
      const key = `${qR},${qG},${qB}`;
      
      colorCounts[key] = (colorCounts[key] || 0) + 1;
    });
    
    // Get top 5 colors
    const sortedColors = Object.entries(colorCounts)
      .sort(([,a], [,b]) => b - a)
      .slice(0, 5)
      .map(([color]) => {
        const [r, g, b] = color.split(',').map(Number);
        return {
          rgb: `rgb(${r}, ${g}, ${b})`,
          hex: `#${r.toString(16).padStart(2, '0')}${g.toString(16).padStart(2, '0')}${b.toString(16).padStart(2, '0')}`,
          values: [r, g, b]
        };
      });
    
    return sortedColors;
  };

  // Generate styled QR code with brand colors
  const generateQRCode = (data, primaryColor) => {
    const vCardData = `BEGIN:VCARD
VERSION:3.0
FN:${data.name}
ORG:${data.organization}
TITLE:${data.title}
TEL:${data.phones[0]}
EMAIL:${data.emails[0]}
URL:${data.website}
ADR:;;${data.address};;;;
END:VCARD`;
    
    return {
      data: vCardData,
      style: {
        foreground: primaryColor?.hex || '#000000',
        background: '#ffffff',
        size: 200
      }
    };
  };

  const handleFileUpload = (event) => {
    const file = event.target.files[0];
    if (file && file.type.startsWith('image/')) {
      const reader = new FileReader();
      reader.onload = (e) => {
        setImage(e.target.result);
        processBusinessCard(file);
      };
      reader.readAsDataURL(file);
    }
  };

  const handleCameraCapture = async () => {
    try {
      const stream = await navigator.mediaDevices.getUserMedia({ 
        video: { facingMode: 'environment' } 
      });
      
      // This would open camera interface in a real implementation
      alert('Camera feature would open here in a full implementation');
    } catch (error) {
      console.error('Camera access failed:', error);
      alert('Camera access denied or not available');
    }
  };

  const downloadVCard = () => {
    if (!qrCode) return;
    
    const blob = new Blob([qrCode.data], { type: 'text/vcard' });
    const url = URL.createObjectURL(blob);
    const a = document.createElement('a');
    a.href = url;
    a.download = `${extractedData.name.replace(/\s+/g, '_')}.vcf`;
    document.body.appendChild(a);
    a.click();
    document.body.removeChild(a);
    URL.revokeObjectURL(url);
  };

  return (
    <div className="min-h-screen bg-gradient-to-br from-blue-50 to-indigo-100 p-6">
      <div className="max-w-6xl mx-auto">
        {/* Header */}
        <div className="text-center mb-8">
          <h1 className="text-4xl font-bold text-gray-800 mb-2 flex items-center justify-center gap-3">
            <Scan className="text-blue-600" size={40} />
            Advanced Card Scanner
          </h1>
          <p className="text-gray-600 text-lg">
            AI-Powered OCR with Logo Color Extraction & Styled QR Generation
          </p>
        </div>

        <div className="grid lg:grid-cols-2 gap-8">
          {/* Left Panel - Upload & Preview */}
          <div className="space-y-6">
            {/* Upload Section */}
            <div className="bg-white rounded-xl shadow-lg p-6">
              <h2 className="text-xl font-semibold mb-4 flex items-center gap-2">
                <Upload className="text-blue-600" size={24} />
                Upload Business Card
              </h2>
              
              <div className="space-y-4">
                <div className="border-2 border-dashed border-gray-300 rounded-lg p-8 text-center hover:border-blue-400 transition-colors">
                  <input
                    ref={fileInputRef}
                    type="file"
                    accept="image/*"
                    onChange={handleFileUpload}
                    className="hidden"
                  />
                  
                  {!image ? (
                    <div className="space-y-4">
                      <Upload className="mx-auto text-gray-400" size={48} />
                      <div>
                        <p className="text-lg text-gray-600 mb-2">
                          Drop your business card image here
                        </p>
                        <p className="text-sm text-gray-500 mb-4">
                          Supports JPG, PNG, HEIC formats
                        </p>
                        <button
                          onClick={() => fileInputRef.current?.click()}
                          className="bg-blue-600 text-white px-6 py-2 rounded-lg hover:bg-blue-700 transition-colors"
                        >
                          Choose File
                        </button>
                      </div>
                    </div>
                  ) : (
                    <div className="space-y-4">
                      <img 
                        src={image} 
                        alt="Business Card" 
                        className="max-w-full max-h-64 mx-auto rounded-lg shadow-md"
                      />
                      <button
                        onClick={() => fileInputRef.current?.click()}
                        className="bg-gray-600 text-white px-4 py-2 rounded-lg hover:bg-gray-700 transition-colors"
                      >
                        Change Image
                      </button>
                    </div>
                  )}
                </div>
                
                <button
                  onClick={handleCameraCapture}
                  className="w-full bg-green-600 text-white py-3 rounded-lg hover:bg-green-700 transition-colors flex items-center justify-center gap-2"
                >
                  <Camera size={20} />
                  Use Camera
                </button>
              </div>
            </div>

            {/* Logo Colors */}
            {logoColors.length > 0 && (
              <div className="bg-white rounded-xl shadow-lg p-6">
                <h3 className="text-lg font-semibold mb-4 flex items-center gap-2">
                  <Palette className="text-purple-600" size={20} />
                  Extracted Brand Colors
                </h3>
                <div className="flex gap-2 flex-wrap">
                  {logoColors.map((color, index) => (
                    <div key={index} className="text-center">
                      <div
                        className="w-12 h-12 rounded-lg shadow-md border-2 border-gray-200"
                        style={{ backgroundColor: color.hex }}
                      />
                      <p className="text-xs mt-1 text-gray-600 font-mono">
                        {color.hex}
                      </p>
                    </div>
                  ))}
                </div>
              </div>
            )}
          </div>

          {/* Right Panel - Results */}
          <div className="space-y-6">
            {isProcessing && (
              <div className="bg-white rounded-xl shadow-lg p-6">
                <div className="flex items-center gap-3">
                  <div className="animate-spin rounded-full h-6 w-6 border-b-2 border-blue-600"></div>
                  <span className="text-lg">Processing with AI-OCR...</span>
                </div>
                <div className="mt-4 bg-gray-200 rounded-full h-2">
                  <div className="bg-blue-600 h-2 rounded-full animate-pulse w-3/4"></div>
                </div>
              </div>
            )}

            {extractedData && (
              <div className="bg-white rounded-xl shadow-lg p-6">
                <div className="flex items-center justify-between mb-4">
                  <h3 className="text-xl font-semibold">Extracted Information</h3>
                  <span className="bg-green-100 text-green-800 px-3 py-1 rounded-full text-sm font-medium">
                    {extractedData.confidence}% Confidence
                  </span>
                </div>
                
                <div className="space-y-4">
                  <div className="grid grid-cols-1 md:grid-cols-2 gap-4">
                    <div>
                      <label className="block text-sm font-medium text-gray-700 mb-1">Name</label>
                      <input
                        type="text"
                        value={extractedData.name}
                        className="w-full p-2 border border-gray-300 rounded-lg focus:ring-2 focus:ring-blue-500 focus:border-transparent"
                        readOnly
                      />
                    </div>
                    
                    {extractedData.nameArabic && (
                      <div>
                        <label className="block text-sm font-medium text-gray-700 mb-1">Name (Arabic)</label>
                        <input
                          type="text"
                          value={extractedData.nameArabic}
                          className="w-full p-2 border border-gray-300 rounded-lg focus:ring-2 focus:ring-blue-500 focus:border-transparent text-right"
                          readOnly
                        />
                      </div>
                    )}
                    
                    <div>
                      <label className="block text-sm font-medium text-gray-700 mb-1">Title</label>
                      <input
                        type="text"
                        value={extractedData.title}
                        className="w-full p-2 border border-gray-300 rounded-lg focus:ring-2 focus:ring-blue-500 focus:border-transparent"
                        readOnly
                      />
                    </div>
                    
                    <div>
                      <label className="block text-sm font-medium text-gray-700 mb-1">Organization</label>
                      <input
                        type="text"
                        value={extractedData.organization}
                        className="w-full p-2 border border-gray-300 rounded-lg focus:ring-2 focus:ring-blue-500 focus:border-transparent"
                        readOnly
                      />
                    </div>
                  </div>
                  
                  <div>
                    <label className="block text-sm font-medium text-gray-700 mb-1">
                      Phone Numbers ({extractedData.phones.length})
                    </label>
                    {extractedData.phones.map((phone, index) => (
                      <input
                        key={index}
                        type="text"
                        value={phone}
                        className="w-full p-2 border border-gray-300 rounded-lg mb-2 focus:ring-2 focus:ring-blue-500 focus:border-transparent"
                        readOnly
                      />
                    ))}
                  </div>
                  
                  <div>
                    <label className="block text-sm font-medium text-gray-700 mb-1">
                      Email Addresses ({extractedData.emails.length})
                    </label>
                    {extractedData.emails.map((email, index) => (
                      <input
                        key={index}
                        type="email"
                        value={email}
                        className="w-full p-2 border border-gray-300 rounded-lg mb-2 focus:ring-2 focus:ring-blue-500 focus:border-transparent"
                        readOnly
                      />
                    ))}
                  </div>
                  
                  <div className="grid grid-cols-1 md:grid-cols-2 gap-4">
                    <div>
                      <label className="block text-sm font-medium text-gray-700 mb-1">Website</label>
                      <input
                        type="text"
                        value={extractedData.website}
                        className="w-full p-2 border border-gray-300 rounded-lg focus:ring-2 focus:ring-blue-500 focus:border-transparent"
                        readOnly
                      />
                    </div>
                    
                    <div className="md:col-span-1">
                      <label className="block text-sm font-medium text-gray-700 mb-1">Address</label>
                      <textarea
                        value={extractedData.address}
                        className="w-full p-2 border border-gray-300 rounded-lg focus:ring-2 focus:ring-blue-500 focus:border-transparent"
                        rows="2"
                        readOnly
                      />
                    </div>
                  </div>
                </div>
              </div>
            )}

            {/* QR Code Generation */}
            {qrCode && (
              <div className="bg-white rounded-xl shadow-lg p-6">
                <h3 className="text-lg font-semibold mb-4 flex items-center gap-2">
                  <QrCode className="text-indigo-600" size={20} />
                  Generated QR Code (vCard)
                </h3>
                
                <div className="flex items-center gap-6">
                  <div className="text-center">
                    <div 
                      className="w-32 h-32 border-2 border-gray-200 rounded-lg flex items-center justify-center text-xs text-gray-500"
                      style={{ 
                        backgroundColor: qrCode.style.background,
                        color: qrCode.style.foreground 
                      }}
                    >
                      QR Code Preview
                      <br />
                      (Styled with brand colors)
                    </div>
                    <p className="text-xs mt-2 text-gray-600">
                      Brand Color: {qrCode.style.foreground}
                    </p>
                  </div>
                  
                  <div className="flex-1">
                    <p className="text-sm text-gray-600 mb-3">
                      Contains complete contact information in vCard format
                    </p>
                    <button
                      onClick={downloadVCard}
                      className="bg-indigo-600 text-white px-4 py-2 rounded-lg hover:bg-indigo-700 transition-colors flex items-center gap-2"
                    >
                      <Download size={16} />
                      Download vCard
                    </button>
                  </div>
                </div>
              </div>
            )}
          </div>
        </div>

        {/* Footer */}
        <div className="mt-12 text-center text-gray-500">
          <p>Powered by Advanced AI-OCR • Supports 100+ Languages • Brand Color Intelligence</p>
        </div>
      </div>
    </div>
  );
};

export default AdvancedCardScanner;
//more
import { createWorker, PSM } from 'tesseract.js';

// Enhanced Contact interface with additional fields
export interface Contact {
  name: string;
  nameArabic?: string;
  email: string;
  emails: string[];
  phone: string;
  phones: string[];
  organization: string;
  title: string;
  address: string;
  website: string;
  websites: string[];
  message1: string;
  message2: string;
  logoColors?: ColorInfo[];
  qrCode?: QRCodeData;
  confidence?: number;
}

export interface ColorInfo {
  hex: string;
  rgb: string;
  hsl: string;
  values: [number, number, number];
  frequency: number;
  name?: string;
}

export interface QRCodeData {
  vCardData: string;
  style: {
    foreground: string;
    background: string;
    size: number;
  };
  logoColor: ColorInfo;
}

interface ExtractedData {
  emails: string[];
  phones: string[];
  websites: string[];
  cleanLines: string[];
  rawText: string;
  confidence: number;
}

interface ProcessingOptions {
  enhanceImage?: boolean;
  extractColors?: boolean;
  generateQR?: boolean;
  multiLanguage?: boolean;
  advancedParsing?: boolean;
}

// Enhanced OCR processing with logo color extraction
export const scanBusinessCardAdvanced = async (
  imageFile: File,
  options: ProcessingOptions = {}
): Promise<Contact> => {
  const {
    enhanceImage = true,
    extractColors = true,
    generateQR = true,
    multiLanguage = true,
    advancedParsing = true
  } = options;

  let processedImage = imageFile;
  
  // Step 1: Image preprocessing
  if (enhanceImage) {
    processedImage = await enhanceImageForOCR(imageFile);
  }

  // Step 2: Extract logo colors first (before OCR)
  let logoColors: ColorInfo[] = [];
  if (extractColors) {
    logoColors = await extractAdvancedLogoColors(processedImage);
  }

  // Step 3: Multi-language OCR with advanced settings
  const languages = multiLanguage ? 'eng+ara+fra+spa+deu+ita+por+rus+chi_sim+jpn+kor+hin+tha+vie' : 'eng+ara';
  const worker = await createWorker(languages);

  try {
    // Enhanced OCR parameters for maximum accuracy
    await worker.setParameters({
      tessedit_char_whitelist: 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789@.+-()[]{}/:;,!?&% \n\r\tأبتثجحخدذرزسشصضطظعغفقكلمنهويىئءآإؤ',
      tessedit_pageseg_mode: PSM.AUTO_OSD,
      preserve_interword_spaces: '1',
      tessedit_ocr_engine_mode: '1',
      tessedit_do_invert: '0',
      textord_really_old_xheight: '1',
      textord_min_xheight: '10',
      classify_enable_learning: '0',
      classify_enable_adaptive_matcher: '1',
      textord_noise_area_ratio: '0.7',
      textord_baseline_debug: '0',
      textord_debug_tabfind: '0',
      textord_heavy_nr: '1',
      language_model_penalty_non_freq_dict_word: '0.1',
      language_model_penalty_non_dict_word: '0.15'
    });

    const { data: { text, confidence } } = await worker.recognize(processedImage);
    
    // Step 4: Advanced parsing
    const extractedData = advancedParsing ? 
      parseBusinessCardAdvanced(text, confidence) : 
      parseBusinessCardBasic(text, confidence);

    // Step 5: Build final contact object
    const contact = buildContactObject(extractedData, logoColors);

    // Step 6: Generate QR code if requested
    if (generateQR && logoColors.length > 0) {
      contact.qrCode = generateStyledQRCode(contact, logoColors[0]);
    }

    await worker.terminate();
    return contact;

  } catch (error) {
    await worker.terminate();
    console.error('Advanced OCR processing failed:', error);
    throw new Error(`Failed to scan business card: ${error.message}`);
  }
};

// Advanced image enhancement for OCR
const enhanceImageForOCR = async (file: File): Promise<File> => {
  return new Promise((resolve, reject) => {
    const canvas = document.createElement('canvas');
    const ctx = canvas.getContext('2d');
    if (!ctx) {
      reject(new Error('Canvas not supported'));
      return;
    }

    const img = new Image();
    img.onload = () => {
      // Calculate optimal size (maintain aspect ratio, max 2000px)
      const maxSize = 2000;
      let { width, height } = img;
      
      if (width > maxSize || height > maxSize) {
        const ratio = Math.min(maxSize / width, maxSize / height);
        width *= ratio;
        height *= ratio;
      }

      canvas.width = width;
      canvas.height = height;

      // Apply advanced image enhancements
      ctx.drawImage(img, 0, 0, width, height);
      
      const imageData = ctx.getImageData(0, 0, width, height);
      const data = imageData.data;

      // Multi-step enhancement
      for (let i = 0; i < data.length; i += 4) {
        let r = data[i];
        let g = data[i + 1];
        let b = data[i + 2];

        // Convert to grayscale with weighted average
        const gray = 0.299 * r + 0.587 * g + 0.114 * b;
        
        // Apply gamma correction
        const gamma = 1.2;
        const corrected = 255 * Math.pow(gray / 255, 1 / gamma);
        
        // Enhance contrast with sigmoid function
        const contrast = 1.5;
        const enhanced = 255 / (1 + Math.exp(-contrast * (corrected - 128) / 128));
        
        // Apply adaptive thresholding
        const threshold = 128;
        const final = enhanced > threshold ? 255 : Math.max(0, enhanced * 0.8);

        data[i] = final;     // Red
        data[i + 1] = final; // Green  
        data[i + 2] = final; // Blue
        // Alpha remains unchanged
      }

      ctx.putImageData(imageData, 0, 0);

      // Convert to high-quality blob
      canvas.toBlob((blob) => {
        if (blob) {
          resolve(new File([blob], file.name, { type: file.type }));
        } else {
          reject(new Error('Failed to enhance image'));
        }
      }, file.type, 0.98);
    };

    img.onerror = () => reject(new Error('Failed to load image'));
    img.src = URL.createObjectURL(file);
  });
};

// Advanced logo color extraction using multiple algorithms
const extractAdvancedLogoColors = async (imageFile: File): Promise<ColorInfo[]> => {
  return new Promise((resolve) => {
    const canvas = document.createElement('canvas');
    const ctx = canvas.getContext('2d');
    if (!ctx) {
      resolve([]);
      return;
    }

    const img = new Image();
    img.onload = () => {
      canvas.width = img.width;
      canvas.height = img.height;
      ctx.drawImage(img, 0, 0);

      const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
      const colors = extractColorsAdvanced(imageData);
      
      resolve(colors);
    };

    img.onerror = () => resolve([]);
    img.src = URL.createObjectURL(imageFile);
  });
};

// Advanced color extraction with multiple algorithms
const extractColorsAdvanced = (imageData: ImageData): ColorInfo[] => {
  const data = imageData.data;
  const colorMap = new Map<string, number>();
  const totalPixels = data.length / 4;

  // Sample pixels with intelligent grid
  const sampleRate = Math.max(1, Math.floor(Math.sqrt(totalPixels) / 100));
  
  for (let i = 0; i < data.length; i += 4 * sampleRate) {
    const r = data[i];
    const g = data[i + 1];
    const b = data[i + 2];
    const a = data[i + 3];

    // Skip transparent, very light, or very dark pixels
    if (a < 128 || (r + g + b) < 100 || (r + g + b) > 650) continue;

    // Quantize colors to reduce noise
    const qR = Math.round(r / 16) * 16;
    const qG = Math.round(g / 16) * 16;
    const qB = Math.round(b / 16) * 16;
    
    const key = `${qR},${qG},${qB}`;
    colorMap.set(key, (colorMap.get(key) || 0) + 1);
  }

  // Get dominant colors
  const sortedColors = Array.from(colorMap.entries())
    .sort(([,a], [,b]) => b - a)
    .slice(0, 10)
    .map(([color, frequency]) => {
      const [r, g, b] = color.split(',').map(Number);
      return createColorInfo(r, g, b, frequency);
    });

  // Apply color harmony analysis
  return analyzeColorHarmony(sortedColors).slice(0, 5);
};

// Create comprehensive color information
const createColorInfo = (r: number, g: number, b: number, frequency: number): ColorInfo => {
  const hex = `#${r.toString(16).padStart(2, '0')}${g.toString(16).padStart(2, '0')}${b.toString(16).padStart(2, '0')}`;
  const rgb = `rgb(${r}, ${g}, ${b})`;
  
  // Convert to HSL
  const hsl = rgbToHsl(r, g, b);
  const hslString = `hsl(${Math.round(hsl[0] * 360)}, ${Math.round(hsl[1] * 100)}%, ${Math.round(hsl[2] * 100)}%)`;
  
  return {
    hex,
    rgb,
    hsl: hslString,
    values: [r, g, b],
    frequency,
    name: getColorName(r, g, b)
  };
};

// RGB to HSL conversion
const rgbToHsl = (r: number, g: number, b: number): [number, number, number] => {
  r /= 255;
  g /= 255;
  b /= 255;

  const max = Math.max(r, g, b);
  const min = Math.